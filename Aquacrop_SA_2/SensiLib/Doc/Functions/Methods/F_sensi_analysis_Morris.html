<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description de F_sensi_analysis_Morris</title>
  <meta name="keywords" content="F_sensi_analysis_Morris">
  <meta name="description" content="Generation des variants pour la methode de Morris.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- menu.html Methods -->
<h1>F_sensi_analysis_Morris
</h1>

<h2><a name="_name"></a>BUT <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Generation des variants pour la methode de Morris.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [vm_F, vm_G, vm_mu, vm_sigma, vm_mu_star, vm_mu_uncert, vm_sigma_uncert, vm_mu_star_uncert] = F_sensi_analysis_Morris(vm_in_mat, vm_out_mat, vs_factors_def, vs_method_options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Generation des variants pour la methode de Morris.

 Cette fonction donne en sortie les matrices de valeur moyenne des taux
      d'accroissement, de la vakeur absolue de ceux-ci et les indices de
      Morris


 ENTREES :

      - vm_in_mat : plan d'expérience des données à analyser (type : matrice de format ((k+1)*r*vs_method_options.m,k)
        avec r le nombre de trajectoires dans l'espace des phases
        constituant le plan d'expérience et k nombre de paramètres en entrée 
        à analyser et m décrits ci-dessous

       - vm_out_mat : f(v_in_mat) avec f le modèle à analyser 

      - vs_factors_def : structure de definition des facteurs
          o vs_factors_def.Dist (OPTIONNEL) : vecteur de cell contenant le type de distribution pour
            chaque facteur.
            Pour voir la liste des distributions disponibles, executer la
            fonction F_create_sample() sans argument.
            ATTENTION: pour utiliser des lois autres que les lois uniforme et 
            triangulaire il est necessaire d'avoir la toolbox matlab &quot;statistics&quot;.
            ATTENTION: la methode ne fonctionne pas avec la distribution
            'discrete'.
            Si ce champ n'est pas precise ou est vide, les distributions des facteurs seront toutes fixees e
            'uniform'. 
            Si le vecteur ne contient qu'une seule distribution alors tous les facteurs auront
            la distribution donnee.
            Dans ces deux derniers cas le champ Nb devra etre
            precise (cf. ci-apres).
          o vs_factors_def.DistParams (OPTIONNEL) : vecteur de cell
            contenant le vecteur des parametres de la distribution 
            pour chaque facteur. 
            Pour voir la liste des parametres requis pour chaque distribution
            disponible, executer la fonction F_create_sample() sans argument.
            Si ce champ n'est pas fourni ou est vide, les parametres
            seront fixes a 0 et 1.
            Si ce champ ne contient qu'un vecteur de parametre, ces
            parametres seront utilises pour toutes les distributions.
          o vs_factors_def.Nb (OPTIONNEL) : scalaire contenant le
            nombre de facteurs. Obligatoire si le champ Dist n'est pas
            precise, est vide ou ne contient qu'une seule distribution. 

      - vs_method_options : structure de definition des options de la
        methode
          o vs_method_options.graph : (OPTIONNEL) 'Si graph = 1, un graphique de sigma 
           en fonction de mu est généré pour chaque variable en sortie, sinon non.
           Valeur par défaut : 1.
          o vs_method_options.incert : (OPTIONNEL) methode d'estimation des
          incertitudes sur les indices calculés : 'bootstrap' (par
          bootstrap, i.e. par ré-échantillonnage de m groupes de trajectoires 
          parmi les r  -&gt; r*(k+1) simulations du modèle), ou 'réplication'
          (par réplication, i.e. qu'on répète m fois le plan d'expérience
          de r trajectoires -&gt; r*(k+1)*m simulations du modèle).
          Valeur par défaut : bootstrap.
          o vs_method_options.m : (OPTIONNEL) nombre de
            ré-échantillonnage boostrap ou nombre de réplicats de groupes de r 
            trajectoires contenus dans la matrice en sortie ou  (selon valeur de vs_method_options.incert).
            Valeur par défaut : r si bootstrap, 5 si réplication.

   SORTIE(S): descriptif des arguments de sortie
      - vm_F : distribution finie Fi (voir &quot;Choix des méthodes
      d'estimation de paramètres pour le projet OptimiSTICS&quot; de Samuel
      BUIS et Daniel WALLACH - version du 07/11/07), matrice de format (nombre
        de facteurs en entrée, nombre de tajectoires par groupe de trajectoires)
        de matrices elle-mêmes de format (nombre de variables en sortie, nombre
        de réplicats de groupes de trajectoires), ce qui donne un matrice 
        &quot;de dimension 4&quot;
      - vm_G : distribution Gi (voir même document), matrice de format (nombre
        de facteurs en entrée, nombre de tajectoires par groupe de trajectoires)
        de matrices elle-mêmes de format (nombre de variables en sortie, nombre
        de réplicats de groupes de trajectoires), ce qui donne un matrice 
        &quot;de dimension 4&quot;
      - vm_mu :  matrice contenant les valeurs moyennes sur l'ensemble des 
                 réplicats des valeurs moyennes sur l'ensemble 
                 des r trajectoires des valeurs en vm_F, avec chaque ligne 
                 correspondant à un paramètre en entrée et chaque colonne 
                 correspondant à une variable en sortie
      - vm_sigma : matrice contenant les valeurs moyennes sur l'ensemble des 
                   réplicats des écarts types sur l'ensemble des
                   trajectoires des valeurs en vm_F, avec chaque ligne 
                   correspondant à un paramètre en entrée et chaque colonne 
                   correspondant à une variable en sortie
      - vm_mu_star : matrice contenant les valeurs moyennes sur l'ensemble des 
                     réplicats des valeurs moyennes sur l'ensemble
                     trajectoires des valeurs en vm_G, avec chaque ligne 
                     correspondant à un paramètre en entrée et chaque colonne 
                     correspondant à une variable en sortie
      - vm_mu_uncert : matrice contenant les écarts-type sur l'ensemble
                       des réplicats des valeurs de vm_mu, avec chaque ligne 
                       correspondant à un paramètre en entrée et chaque colonne 
                       correspondant à une variable en sortie
      - vm_sigma_uncert : matrice contenant les écarts-type sur l'ensemble
                          des réplicats des valeurs de vm_sigma, avec chaque ligne 
                          correspondant à un paramètre en entrée et chaque colonne 
                          correspondant à une variable en sortie
      -vm_mu_star_uncert : matrice contenant les écarts-type sur l'ensemble
                           des réplicats des valeurs de vm_mu_star, avec chaque ligne 
                           correspondant à un paramètre en entrée et chaque colonne 
                           correspondant à une variable en sortie
  
   CONTENU: descriptif de la fonction
      - donne en sortie les matrices de valeur moyenne des taux
      d'accroissement, de la valeur absolue de ceux-ci et les indices de
      Morris ainsi que lmeurs écarts-types sur l'ensemble des m réplicats
     
  AUTEUR(S): Cyril AUCLAIR (stagiaire de Samuel BUIS à l'INRA PACA mai-septembre 2013)
  DATE CREATION: 13-Jun-2013
  
  MODIFICATIONS (last commit)
    $Date: 2013-06-19 14:49:50 +0200 (mer., 19 juin 2013) $
    $Author: plecharpent $
    $Revision: 40 $
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>INFORMATION SUR LES REFERENCES CROISEES <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
Cette fonction fait appel à:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
Cette fonction est appelée par:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../Demo/F_AS_demo.html" class="code" title="function [vs_indices,v_out_mat,v_in_mat]= F_AS_demo(v_lib_dir)">F_AS_demo</a>	Test des méthodes d'analyse de sensibilité.</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>CODE SOURCE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [vm_F, vm_G, vm_mu, vm_sigma, vm_mu_star, vm_mu_uncert, vm_sigma_uncert, vm_mu_star_uncert] = F_sensi_analysis_Morris(vm_in_mat, vm_out_mat, vs_factors_def, vs_method_options)</a>
0002 <span class="comment">% Generation des variants pour la methode de Morris.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Cette fonction donne en sortie les matrices de valeur moyenne des taux</span>
0005 <span class="comment">%      d'accroissement, de la vakeur absolue de ceux-ci et les indices de</span>
0006 <span class="comment">%      Morris</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% ENTREES :</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%      - vm_in_mat : plan d'expérience des données à analyser (type : matrice de format ((k+1)*r*vs_method_options.m,k)</span>
0012 <span class="comment">%        avec r le nombre de trajectoires dans l'espace des phases</span>
0013 <span class="comment">%        constituant le plan d'expérience et k nombre de paramètres en entrée</span>
0014 <span class="comment">%        à analyser et m décrits ci-dessous</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%       - vm_out_mat : f(v_in_mat) avec f le modèle à analyser</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%      - vs_factors_def : structure de definition des facteurs</span>
0019 <span class="comment">%          o vs_factors_def.Dist (OPTIONNEL) : vecteur de cell contenant le type de distribution pour</span>
0020 <span class="comment">%            chaque facteur.</span>
0021 <span class="comment">%            Pour voir la liste des distributions disponibles, executer la</span>
0022 <span class="comment">%            fonction F_create_sample() sans argument.</span>
0023 <span class="comment">%            ATTENTION: pour utiliser des lois autres que les lois uniforme et</span>
0024 <span class="comment">%            triangulaire il est necessaire d'avoir la toolbox matlab &quot;statistics&quot;.</span>
0025 <span class="comment">%            ATTENTION: la methode ne fonctionne pas avec la distribution</span>
0026 <span class="comment">%            'discrete'.</span>
0027 <span class="comment">%            Si ce champ n'est pas precise ou est vide, les distributions des facteurs seront toutes fixees e</span>
0028 <span class="comment">%            'uniform'.</span>
0029 <span class="comment">%            Si le vecteur ne contient qu'une seule distribution alors tous les facteurs auront</span>
0030 <span class="comment">%            la distribution donnee.</span>
0031 <span class="comment">%            Dans ces deux derniers cas le champ Nb devra etre</span>
0032 <span class="comment">%            precise (cf. ci-apres).</span>
0033 <span class="comment">%          o vs_factors_def.DistParams (OPTIONNEL) : vecteur de cell</span>
0034 <span class="comment">%            contenant le vecteur des parametres de la distribution</span>
0035 <span class="comment">%            pour chaque facteur.</span>
0036 <span class="comment">%            Pour voir la liste des parametres requis pour chaque distribution</span>
0037 <span class="comment">%            disponible, executer la fonction F_create_sample() sans argument.</span>
0038 <span class="comment">%            Si ce champ n'est pas fourni ou est vide, les parametres</span>
0039 <span class="comment">%            seront fixes a 0 et 1.</span>
0040 <span class="comment">%            Si ce champ ne contient qu'un vecteur de parametre, ces</span>
0041 <span class="comment">%            parametres seront utilises pour toutes les distributions.</span>
0042 <span class="comment">%          o vs_factors_def.Nb (OPTIONNEL) : scalaire contenant le</span>
0043 <span class="comment">%            nombre de facteurs. Obligatoire si le champ Dist n'est pas</span>
0044 <span class="comment">%            precise, est vide ou ne contient qu'une seule distribution.</span>
0045 <span class="comment">%</span>
0046 <span class="comment">%      - vs_method_options : structure de definition des options de la</span>
0047 <span class="comment">%        methode</span>
0048 <span class="comment">%          o vs_method_options.graph : (OPTIONNEL) 'Si graph = 1, un graphique de sigma</span>
0049 <span class="comment">%           en fonction de mu est généré pour chaque variable en sortie, sinon non.</span>
0050 <span class="comment">%           Valeur par défaut : 1.</span>
0051 <span class="comment">%          o vs_method_options.incert : (OPTIONNEL) methode d'estimation des</span>
0052 <span class="comment">%          incertitudes sur les indices calculés : 'bootstrap' (par</span>
0053 <span class="comment">%          bootstrap, i.e. par ré-échantillonnage de m groupes de trajectoires</span>
0054 <span class="comment">%          parmi les r  -&gt; r*(k+1) simulations du modèle), ou 'réplication'</span>
0055 <span class="comment">%          (par réplication, i.e. qu'on répète m fois le plan d'expérience</span>
0056 <span class="comment">%          de r trajectoires -&gt; r*(k+1)*m simulations du modèle).</span>
0057 <span class="comment">%          Valeur par défaut : bootstrap.</span>
0058 <span class="comment">%          o vs_method_options.m : (OPTIONNEL) nombre de</span>
0059 <span class="comment">%            ré-échantillonnage boostrap ou nombre de réplicats de groupes de r</span>
0060 <span class="comment">%            trajectoires contenus dans la matrice en sortie ou  (selon valeur de vs_method_options.incert).</span>
0061 <span class="comment">%            Valeur par défaut : r si bootstrap, 5 si réplication.</span>
0062 <span class="comment">%</span>
0063 <span class="comment">%   SORTIE(S): descriptif des arguments de sortie</span>
0064 <span class="comment">%      - vm_F : distribution finie Fi (voir &quot;Choix des méthodes</span>
0065 <span class="comment">%      d'estimation de paramètres pour le projet OptimiSTICS&quot; de Samuel</span>
0066 <span class="comment">%      BUIS et Daniel WALLACH - version du 07/11/07), matrice de format (nombre</span>
0067 <span class="comment">%        de facteurs en entrée, nombre de tajectoires par groupe de trajectoires)</span>
0068 <span class="comment">%        de matrices elle-mêmes de format (nombre de variables en sortie, nombre</span>
0069 <span class="comment">%        de réplicats de groupes de trajectoires), ce qui donne un matrice</span>
0070 <span class="comment">%        &quot;de dimension 4&quot;</span>
0071 <span class="comment">%      - vm_G : distribution Gi (voir même document), matrice de format (nombre</span>
0072 <span class="comment">%        de facteurs en entrée, nombre de tajectoires par groupe de trajectoires)</span>
0073 <span class="comment">%        de matrices elle-mêmes de format (nombre de variables en sortie, nombre</span>
0074 <span class="comment">%        de réplicats de groupes de trajectoires), ce qui donne un matrice</span>
0075 <span class="comment">%        &quot;de dimension 4&quot;</span>
0076 <span class="comment">%      - vm_mu :  matrice contenant les valeurs moyennes sur l'ensemble des</span>
0077 <span class="comment">%                 réplicats des valeurs moyennes sur l'ensemble</span>
0078 <span class="comment">%                 des r trajectoires des valeurs en vm_F, avec chaque ligne</span>
0079 <span class="comment">%                 correspondant à un paramètre en entrée et chaque colonne</span>
0080 <span class="comment">%                 correspondant à une variable en sortie</span>
0081 <span class="comment">%      - vm_sigma : matrice contenant les valeurs moyennes sur l'ensemble des</span>
0082 <span class="comment">%                   réplicats des écarts types sur l'ensemble des</span>
0083 <span class="comment">%                   trajectoires des valeurs en vm_F, avec chaque ligne</span>
0084 <span class="comment">%                   correspondant à un paramètre en entrée et chaque colonne</span>
0085 <span class="comment">%                   correspondant à une variable en sortie</span>
0086 <span class="comment">%      - vm_mu_star : matrice contenant les valeurs moyennes sur l'ensemble des</span>
0087 <span class="comment">%                     réplicats des valeurs moyennes sur l'ensemble</span>
0088 <span class="comment">%                     trajectoires des valeurs en vm_G, avec chaque ligne</span>
0089 <span class="comment">%                     correspondant à un paramètre en entrée et chaque colonne</span>
0090 <span class="comment">%                     correspondant à une variable en sortie</span>
0091 <span class="comment">%      - vm_mu_uncert : matrice contenant les écarts-type sur l'ensemble</span>
0092 <span class="comment">%                       des réplicats des valeurs de vm_mu, avec chaque ligne</span>
0093 <span class="comment">%                       correspondant à un paramètre en entrée et chaque colonne</span>
0094 <span class="comment">%                       correspondant à une variable en sortie</span>
0095 <span class="comment">%      - vm_sigma_uncert : matrice contenant les écarts-type sur l'ensemble</span>
0096 <span class="comment">%                          des réplicats des valeurs de vm_sigma, avec chaque ligne</span>
0097 <span class="comment">%                          correspondant à un paramètre en entrée et chaque colonne</span>
0098 <span class="comment">%                          correspondant à une variable en sortie</span>
0099 <span class="comment">%      -vm_mu_star_uncert : matrice contenant les écarts-type sur l'ensemble</span>
0100 <span class="comment">%                           des réplicats des valeurs de vm_mu_star, avec chaque ligne</span>
0101 <span class="comment">%                           correspondant à un paramètre en entrée et chaque colonne</span>
0102 <span class="comment">%                           correspondant à une variable en sortie</span>
0103 <span class="comment">%</span>
0104 <span class="comment">%   CONTENU: descriptif de la fonction</span>
0105 <span class="comment">%      - donne en sortie les matrices de valeur moyenne des taux</span>
0106 <span class="comment">%      d'accroissement, de la valeur absolue de ceux-ci et les indices de</span>
0107 <span class="comment">%      Morris ainsi que lmeurs écarts-types sur l'ensemble des m réplicats</span>
0108 <span class="comment">%</span>
0109 <span class="comment">%  AUTEUR(S): Cyril AUCLAIR (stagiaire de Samuel BUIS à l'INRA PACA mai-septembre 2013)</span>
0110 <span class="comment">%  DATE CREATION: 13-Jun-2013</span>
0111 <span class="comment">%</span>
0112 <span class="comment">%  MODIFICATIONS (last commit)</span>
0113 <span class="comment">%    $Date: 2013-06-19 14:49:50 +0200 (mer., 19 juin 2013) $</span>
0114 <span class="comment">%    $Author: plecharpent $</span>
0115 <span class="comment">%    $Revision: 40 $</span>
0116 <span class="comment">%</span>
0117 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0118 
0119 
0120 <span class="comment">%% Definition du tableau contenant les options de la methode</span>
0121 vc_options_desc=struct(<span class="string">'name'</span>,{<span class="string">'graph'</span>,<span class="string">'incert'</span>,<span class="string">'m'</span>},<span class="keyword">...</span>
0122     <span class="string">'datatype'</span>,{<span class="string">'uint32'</span>,<span class="string">'char'</span>,<span class="string">'uint32'</span>},<span class="keyword">...</span>
0123     <span class="string">'status'</span>,{<span class="string">'optional'</span>,<span class="string">'optional'</span>,<span class="string">'optional'</span>},<span class="keyword">...</span>
0124     <span class="string">'defaultvalue'</span>,{1,<span class="string">'bootstrap'</span>,[]},<span class="keyword">...</span>
0125     <span class="string">'comments'</span>,{<span class="string">'Si graph = 1, un graphique de sigma sur |mu| est généré pour chaque variable en sortie, sinon non.'</span>,<span class="keyword">...</span>
0126                 <span class="string">'Méthode d''estimation des incertitudes sur les indices calculés : ''bootstrap'' ou ''réplication'''</span>,<span class="keyword">...</span>
0127                 <span class="string">'Nombre de ré-échantillonnages boostrap ou nombre de réplicats de groupes r trajectoires'</span>});
0128 
0129 <span class="comment">%% Retour de la structure pour verification si appel sans arguments</span>
0130 <span class="keyword">if</span> nargin==0
0131     vm_F=vc_options_desc;
0132     <span class="keyword">return</span>
0133 <span class="keyword">end</span>
0134 
0135 <span class="comment">%% Renseignement des options par defaut</span>
0136 <span class="keyword">for</span> i=1:length(vc_options_desc)
0137     <span class="keyword">if</span> ~isfield(vs_method_options,vc_options_desc(i).name)
0138         <span class="keyword">if</span> strmatch(<span class="string">'optional'</span>,vc_options_desc(i).status,<span class="string">'exact'</span>)
0139             vs_method_options.(vc_options_desc(i).name)=vc_options_desc(i).defaultvalue;
0140         <span class="keyword">else</span>
0141             error([<span class="string">'L''option '</span> vc_options_desc(i).name <span class="string">' doit etre renseignee.'</span>])
0142         <span class="keyword">end</span>
0143     <span class="keyword">end</span>
0144 <span class="keyword">end</span>
0145 <span class="keyword">if</span> ~isfield(vs_method_options,<span class="string">'m'</span>) || isempty(vs_method_options.m)
0146     <span class="keyword">if</span> strcmp(lower(vs_method_options.incert),<span class="string">'bootstrap'</span>)
0147         vs_method_options.m=vs_method_options.r;
0148     <span class="keyword">elseif</span> strcmp(lower(vs_method_options.incert),<span class="string">'replication'</span>)
0149         vs_method_options.m=5;
0150     <span class="keyword">end</span>
0151 <span class="keyword">end</span>
0152 
0153 <span class="comment">%% Tests divers sur les arguments</span>
0154 <span class="keyword">if</span> ~isfield(vs_factors_def,<span class="string">'Dist'</span>) || isempty(vs_factors_def.Dist)
0155     vs_factors_def.Dist={<span class="string">'uniform'</span>};
0156 <span class="keyword">end</span>
0157 <span class="keyword">if</span> length(vs_factors_def.Dist)==1
0158     F_create_message(<span class="string">'Probleme dans les arguments en entree'</span>,<span class="keyword">...</span>
0159             <span class="string">'Lorsque le champ dist de l''argument vs_factors_def n''est pas fourni ou ne contient qu''une distribution, le champ Nb de l''argument vs_factors_def doit etre defini.'</span>,<span class="keyword">...</span>
0160             ~isfield(vs_factors_def,<span class="string">'Nb'</span>) || isempty(vs_factors_def.Nb),1);
0161     vs_factors_def.Dist=mat2cell(repmat(vs_factors_def.Dist{1},vs_factors_def.Nb,1),ones(1,vs_factors_def.Nb),length(vs_factors_def.Dist{1}));
0162 <span class="keyword">else</span>
0163     vs_factors_def.Nb=length(vs_factors_def.Dist);
0164 <span class="keyword">end</span>
0165 F_create_message(<span class="string">''</span>,<span class="keyword">...</span>
0166     <span class="string">'La methode ne fonctionne pas avec la distribution ''discrete''.'</span>,<span class="keyword">...</span>
0167     ~isempty(strmatch(<span class="string">'discrete'</span>,vs_factors_def.Dist,<span class="string">'exact'</span>)),1);
0168 <span class="keyword">if</span> ~isfield(vs_factors_def,<span class="string">'DistParams'</span>) || isempty(vs_factors_def.DistParams)
0169     vs_factors_def.DistParams={[0,1]};
0170 <span class="keyword">end</span>
0171 <span class="keyword">if</span> length(vs_factors_def.DistParams)==1
0172     <span class="keyword">for</span> i=2:vs_factors_def.Nb
0173         vs_factors_def.DistParams{i}=vs_factors_def.DistParams{1};
0174     <span class="keyword">end</span>
0175 <span class="keyword">end</span>      
0176 <span class="keyword">for</span> i=1:vs_factors_def.Nb
0177     [v_checked, v_flag_bounded] = F_check_distr(vs_factors_def.Dist{i},vs_factors_def.DistParams{i});
0178     F_create_message([<span class="string">'Problème avec la distribution du facteur '</span> num2str(i)],<span class="keyword">...</span>
0179         <span class="string">'La methode ne fonctionne pas avec les distributions non bornées.'</span>,<span class="keyword">...</span>
0180         ~v_flag_bounded,1);
0181     F_create_message([<span class="string">'Problème avec la distribution du facteur '</span> num2str(i)],<span class="keyword">...</span>
0182         <span class="string">'Voir messages ci-dessus.'</span>,<span class="keyword">...</span>
0183         ~v_checked,1);
0184 <span class="keyword">end</span>
0185 
0186 <span class="comment">%% Code de la fonction</span>
0187 
0188 m = vs_method_options.m;
0189 k = size(vm_in_mat,2); <span class="comment">% dimension de la grille régulière</span>
0190 n = size(vm_out_mat,2); <span class="comment">% nombre de variables de sortie</span>
0191 
0192 <span class="comment">% On recalcule le plan d'expérience normalisé</span>
0193 vm_in_mat_norm=zeros(size(vm_in_mat));
0194 <span class="keyword">for</span> i=1:k
0195     [v_tmp, vm_in_mat_norm(:,i)]=F_cdf(vs_factors_def.Dist{i},vs_factors_def.DistParams{i},vm_in_mat(:,i));
0196 <span class="keyword">end</span>
0197 
0198 <span class="comment">% On enlève les trajectoire dans lesquelles il y a des pb dans la</span>
0199 <span class="comment">% simulation</span>
0200 v_ind=sum(isnan(vm_out_mat)+isinf(vm_out_mat),2);
0201 v_indtraj=unique(floor((find(v_ind)-1)/(k+1)));
0202 v_indremove=[];
0203 <span class="keyword">for</span> i=1:length(v_indtraj)
0204     v_indremove=[v_indremove,v_indtraj(i)*(k+1)+1:(v_indtraj(i)+1)*(k+1)];
0205 <span class="keyword">end</span>
0206 vm_in_mat_norm(v_indremove,:)=[];
0207 vm_out_mat(v_indremove,:)=[];
0208 <span class="keyword">if</span> strcmpi(vs_method_options.incert,<span class="string">'bootstrap'</span>)
0209     r = size(vm_in_mat_norm,1)/(k+1); <span class="comment">% nombre de trajectoires</span>
0210     vm_F = zeros(k,m,n,m); <span class="comment">% matrice de format(k,r,n,m) destinee à contenir toutes les matrices Fm,i</span>
0211     vm_F_concat = zeros(k,m*m,n);  <span class="comment">% matrice de format(k,r*m,n) destinee à contenir toutes les matrices Fm,i de façon concaténée</span>
0212 <span class="keyword">elseif</span> strcmpi(vs_method_options.incert,<span class="string">'replication'</span>)
0213     r = size(vm_in_mat_norm,1)/((k+1)*m) ; <span class="comment">% nombre de trajectoires</span>
0214     vm_F = zeros(k,r,n,m); <span class="comment">% matrice de format(k,r,n,m) destinee à contenir toutes les matrices Fm,i</span>
0215     vm_F_concat = zeros(k,r*m,n);  <span class="comment">% matrice de format(k,r*m,n) destinee à contenir toutes les matrices Fm,i de façon concaténée</span>
0216 <span class="keyword">end</span>
0217 <span class="keyword">if</span> ~isempty(v_indremove)
0218     F_disp(sprintf(<span class="string">'\nAttention des trajectoires ont été enlevées dans le plan d''experience de la méthode de Morris, il en reste %s'</span>,num2str(r)))
0219 <span class="keyword">end</span>
0220 vm_M001 = zeros(k,k,m); <span class="comment">% matrice de format (k,k) dont tous les éléments valent zéro initialement</span>
0221 vv_j = 1 : k;
0222 vv_d = zeros(k,n,m); <span class="comment">% matrice de de format (k,n,m) destinee a contenir à chacune la valeur d = +/- delta pour le parametre correspondant dupliquee à chaque colonne</span>
0223 
0224 <span class="keyword">for</span> l = 1 : m
0225     <span class="keyword">if</span> strcmpi(vs_method_options.incert,<span class="string">'bootstrap'</span>)
0226         ind=randsample(r,m,true); <span class="comment">% ré-échantillonnage avec remise des trajectoires</span>
0227         <span class="keyword">for</span> i=1:m
0228             vm_in_mat_norm_l((i-1)*(k+1)+1:i*(k+1),:)=vm_in_mat_norm((ind(i)-1)*(k+1)+1:ind(i)*(k+1),:);
0229             vm_out_mat_l((i-1)*(k+1)+1:i*(k+1),:)=vm_out_mat((ind(i)-1)*(k+1)+1:ind(i)*(k+1),:);
0230         <span class="keyword">end</span>
0231     <span class="keyword">elseif</span> strcmpi(vs_method_options.incert,<span class="string">'replication'</span>)
0232         vm_in_mat_norm_l=vm_in_mat_norm((l-1)*r*(k+1)+1:l*r*(k+1),:);
0233         vm_out_mat_l=vm_out_mat((l-1)*r*(k+1)+1:l*r*(k+1),:);
0234     <span class="keyword">end</span>
0235     <span class="keyword">for</span> i = 1:size(vm_in_mat_norm_l,1)/(k+1)
0236             vm_M001(:,vv_j,l) = vm_in_mat_norm_l((i-1)*(k+1)+vv_j+1,:)-vm_in_mat_norm_l((i-1)*(k+1)+vv_j,:); <span class="comment">% matrice tels que vm_M1(j,:) = Bi*(j+1,:)-Bi*(j,:)</span>
0237             vm_M004 = sum(vm_M001,2);
0238             <span class="keyword">for</span> j = 1:n
0239                 vv_d(:,j,l) = vm_M004(:,:,l);
0240             <span class="keyword">end</span>
0241             vm_M002 = vm_M001|0;
0242             vv_m = vm_M002(:,:,l)*(vv_j');  
0243             vm_M005 = (vm_out_mat_l((i-1)*(k+1)+vv_j+1,:)-vm_out_mat_l((i-1)*(k+1)+vv_j,:));
0244             vm_M005=vm_M005./vv_d(:,:,l);
0245             <span class="keyword">for</span> j = 1 : k
0246                 vm_F(vv_m(j),i,:,l) = vm_M005(j,:);
0247                 vm_F_concat(vv_m(j),(l-1)*r+i,:) = vm_M005(j,:);
0248             <span class="keyword">end</span>
0249     <span class="keyword">end</span>
0250 <span class="keyword">end</span>
0251 vm_G = abs(vm_F);
0252 vm_mu_rep = reshape(mean(vm_F(:,:,:,:),2),k,n,m);
0253 vm_mu = reshape(mean(vm_mu_rep,3),k,n);
0254 vm_mu_star_rep = reshape(mean(vm_G(:,:,:,:),2),k,n,m);
0255 vm_mu_star = reshape(mean(vm_mu_star_rep,3),k,n);
0256 vm_sigma_rep = reshape(std(vm_F(:,:,:,:),0,2),k,n,m);
0257 vm_sigma = reshape(std(vm_F_concat,0,2),k,n);
0258 
0259 vm_mu_uncert = reshape(std(vm_mu_rep,0,3),k,n);
0260 vm_mu_star_uncert = reshape(std(vm_mu_star_rep,0,3),k,n);
0261 vm_sigma_uncert = reshape(std(vm_sigma_rep,0,3),k,n);
0262 
0263 
0264 
0265 <span class="keyword">if</span> vs_method_options.graph == 1
0266     
0267     <span class="keyword">for</span> j = 1:n
0268         
0269         [vm_mu_star_decroissant, vv_index_mu_star_decroissant] = sort(vm_mu_star(:,j), <span class="string">'descend'</span>);
0270         vv_chaineDeCaracteresSortie1 = <span class="string">'  '</span>;
0271         vv_chaineDeCaracteresSortie2 = <span class="string">'µ* : '</span>;
0272         disp([<span class="string">'valeur de µ* pour les différents paramètres pour la variable '</span> num2str(j)])
0273         <span class="keyword">for</span> i = 1:size(vm_mu_star)
0274             vv_chaineDeCaracteresSortie1 = [vv_chaineDeCaracteresSortie1, <span class="string">'   X'</span>, num2str(vv_index_mu_star_decroissant(i)),<span class="string">'      '</span>];
0275             vv_chaineDeCaracteresSortie2 = [vv_chaineDeCaracteresSortie2, num2str(vm_mu_star_decroissant(i), <span class="string">'%3.2e'</span>),<span class="string">' ; '</span> ];
0276         <span class="keyword">end</span>
0277         disp(vv_chaineDeCaracteresSortie1);
0278         <span class="comment">%disp(['µ* : ', num2str(vm_mu_star_decroissant', '%3.2e')]);</span>
0279         disp(vv_chaineDeCaracteresSortie2);
0280 
0281         figure
0282         hold on
0283         <span class="keyword">if</span> m&gt;1
0284           errorbar(vm_mu(:,j), vm_sigma(:,j), vm_sigma_uncert(:,j), <span class="string">'.'</span>) <span class="comment">% on pourrait tracer des boxplot fin (est-ce que ça existe en horizontal ?) ...</span>
0285           herrorbar(vm_mu(:,j), vm_sigma(:,j), vm_mu_uncert(:,j), <span class="string">'.'</span>) <span class="comment">% ... ou le min et max (mais retourner en sortie les ect)</span>
0286         <span class="keyword">end</span>
0287         xlim([min(-1.1*max(abs(vm_mu(:,j))+vm_mu_uncert(:,j)),-0.1) max(1.1*max(abs(vm_mu(:,j))+vm_mu_uncert(:,j)),0.1)])
0288         ylim([min(min(abs(vm_sigma(:,j))-vm_sigma_uncert(:,j))-0.1*abs(min(abs(vm_sigma(:,j))-vm_sigma_uncert(:,j))),0) max(1.1*max(abs(vm_sigma(:,j))+vm_sigma_uncert(:,j)),0.1)])
0289         plot([0 0],ylim,<span class="string">'--'</span>)
0290         xminmax=xlim;
0291         yminmax=ylim;
0292         xoffset=diff(xlim)/100;
0293         yoffset=diff(ylim)/50;
0294         text(vm_mu(:,j)+xoffset, vm_sigma(:,j)+yoffset,num2str([1 : k]'))
0295         plot([max(xminmax(1),-yminmax(2)) 0],[abs(max(xminmax(1),-yminmax(2))) 0],<span class="string">'r--'</span>)
0296         plot([0 min(xminmax(2),yminmax(2))],[0 min(xminmax(2),yminmax(2))],<span class="string">'r--'</span>)
0297         hold off
0298         xlabel(<span class="string">'µ'</span>);
0299         ylabel(<span class="string">'sigma'</span>);
0300         title([<span class="string">'indice de Morris des différents paramètres, variable '</span> num2str(j)])
0301     
0302         figure
0303         <span class="keyword">for</span> i=1:k
0304             subplot(ceil(sqrt(k)),ceil(sqrt(k)),i)
0305             hist(squeeze(vm_F_concat(i,:,j)),20);
0306             title([<span class="string">'Histogramme F, paramètre '</span> num2str(i) <span class="string">', variable '</span> num2str(j)])
0307         <span class="keyword">end</span>
0308         
0309     <span class="keyword">end</span>
0310 <span class="keyword">end</span>
0311 <span class="keyword">end</span></pre></div>
<hr><address>Généré le Tue 18-Mar-2014 17:21:41 par <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>